# https://github.com/UB-Mannheim/tesseract/wiki  ë‹¤ìŒ ë¦¼í¬ì—ì„œ tesseract ë¥¼ ê¹”ì•„ì•¼ í•©ë‹ˆë‹¤
# pip install pandas geopy PyQt5 PyQtWebEngine
# pip install pytesseract pillow


import os
import re
from PIL import Image
import pytesseract
import sys
import math
import pandas as pd
from datetime import datetime, timedelta
from PyQt5.QtWidgets import QFileDialog
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QLineEdit, QPushButton, QListWidget, QMessageBox,
    QCheckBox, QComboBox, QDialog, QSpacerItem, QSizePolicy, QTabWidget
)
from PyQt5.QtWebEngineWidgets import QWebEngineView
from PyQt5.QtCore import QTimer
pytesseract.pytesseract.tesseract_cmd = r'C:\Program Files\Tesseract-OCR\tesseract.exe'

# ========== ìœ í†µê¸°í•œ ê´€ë¦¬ ê¸°ì¡´ ì½”ë“œ ==========
simulated_now = datetime.now()
def get_now():
    return simulated_now

class FoodItem:
    def __init__(self, name, expiry_date_str):
        self.name = name
        try:
            self.expiry_date = datetime.strptime(expiry_date_str, "%Y-%m-%d").replace(hour=23, minute=59, second=59)
        except ValueError:
            raise ValueError("ë‚ ì§œ í˜•ì‹ì´ ìž˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤.")
        self.added_at = get_now()
    def time_left(self):
        return self.expiry_date - get_now()
    def is_expired(self):
        return get_now() > self.expiry_date
    def __str__(self):
        if self.is_expired():
            delta = get_now() - self.expiry_date
            return f"{self.name} (ìœ í†µê¸°í•œ: {self.expiry_date.strftime('%Y-%m-%d')}) - {delta.days}ì¼ ì§€ë‚¨"
        else:
            delta = self.time_left()
            days = delta.days
            hours, remainder = divmod(delta.seconds, 3600)
            return f"{self.name} (ìœ í†µê¸°í•œ: {self.expiry_date.strftime('%Y-%m-%d')}) - {days}ì¼ {hours}ì‹œê°„ ë‚¨ìŒ"

class SettingsDialog(QDialog):
    def __init__(self, parent=None, current_settings=None):
        super().__init__(parent)
        self.setWindowTitle("ì•Œë¦¼ ì„¤ì •")
        self.settings = current_settings.copy() if current_settings else {}
        self.layout = QVBoxLayout(self)
        self.night_notify_checkbox = QCheckBox("ë°¤ì—ë„ ì•Œë¦¼ ë°›ê¸° (22:00 ~ 08:00)")
        self.night_notify_checkbox.setChecked(self.settings.get("night_notify", True))
        self.layout.addWidget(self.night_notify_checkbox)
        notify_time_layout = QHBoxLayout()
        notify_time_label = QLabel("ìœ í†µê¸°í•œ ìž„ë°• ì•Œë¦¼ ì‹œê°„:")
        self.notify_time_combo = QComboBox()
        self.notify_time_combo.addItems(["12ì‹œê°„ ì „", "24ì‹œê°„ ì „", "48ì‹œê°„ ì „", "72ì‹œê°„ ì „"])
        hours_map = {"12": 0, "24": 1, "48": 2, "72": 3}
        current_hours = str(self.settings.get("notify_hours_before", 24))
        self.notify_time_combo.setCurrentIndex(hours_map.get(current_hours, 1))
        notify_time_layout.addWidget(notify_time_label)
        notify_time_layout.addWidget(self.notify_time_combo)
        self.layout.addLayout(notify_time_layout)
        button_box = QHBoxLayout()
        ok_button = QPushButton("ì €ìž¥")
        ok_button.clicked.connect(self.accept)
        cancel_button = QPushButton("ì·¨ì†Œ")
        cancel_button.clicked.connect(self.reject)
        button_box.addSpacerItem(QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum))
        button_box.addWidget(ok_button)
        button_box.addWidget(cancel_button)
        self.layout.addLayout(button_box)
    def get_settings(self):
        self.settings["night_notify"] = self.night_notify_checkbox.isChecked()
        hours = int(self.notify_time_combo.currentText().split('ì‹œê°„')[0])
        self.settings["notify_hours_before"] = hours
        return self.settings

# ========== í´ë¦°í•˜ìš°ìŠ¤ ì¶”ì²œ ê¸°ëŠ¥ ==========
def load_cleanhouse_list(filepath):
    df = pd.read_excel(filepath, sheet_name='í´ë¦°í•˜ìš°ìŠ¤ ëª©ë¡')
    df = df[(df['ì‚¬ìš©ì—¬ë¶€'] == 'Y') & df['ìœ„ë„'].notnull() & df['ê²½ë„'].notnull()]
    return df
# ========== ìœ í†µê¸°í•œ ì¶”ì¶œ ==========

import re

def extract_date(data):
    tempB = []
    pat = r'\d{2,4}\W\d{2}\W\d{2}'
    temp_A = re.findall(pat, data)

    for tempf in temp_A:
        # êµ¬ë¶„ìžë¥¼ '-'ë¡œ í†µì¼
        date = re.sub(r'\W', '-', tempf)
        # ì—°ë„ê°€ ë‘ ìžë¦¬ë©´ '20' ë¶™ì´ê¸°
        parts = date.split('-')
        if len(parts[0]) == 2:
            parts[0] = '20' + parts[0]
        date = '-'.join(parts)
        tempB.append(date)

    result = sorted(tempB, reverse=True)
    return (result)

def use_by_date(image_path):
    image = Image.open(image_path)
    text = pytesseract.image_to_string(image, lang='eng')
    return extract_date(text)

# Nominatim API (geopy) ì‚¬ìš©
from geopy.geocoders import Nominatim
def geocode_address(address):
    geolocator = Nominatim(user_agent="CleanHouseFinder")
    try:
        location = geolocator.geocode(address, timeout=10)
        if location:
            return location.latitude, location.longitude
    except Exception as e:
        print(f"ì§€ì˜¤ì½”ë”© ì˜¤ë¥˜: {str(e)}")
    return None

def haversine(lat1, lon1, lat2, lon2):
    R = 6371
    dlat = math.radians(lat2 - lat1)
    dlon = math.radians(lon2 - lon1)
    a = (math.sin(dlat/2)**2 +
         math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) *
         math.sin(dlon/2)**2)
    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
    return R * c

def find_nearest_cleanhouses(user_lat, user_lng, cleanhouse_df, top_n=5):
    cleanhouse_df = cleanhouse_df.copy()
    cleanhouse_df['ê±°ë¦¬'] = cleanhouse_df.apply(
        lambda row: haversine(user_lat, user_lng, row['ìœ„ë„'], row['ê²½ë„']), axis=1)
    return cleanhouse_df.sort_values('ê±°ë¦¬').head(top_n)

class CleanhouseFinder(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QVBoxLayout(self)
        self.address_input = QLineEdit()
        self.address_input.setPlaceholderText("ì§‘ ì£¼ì†Œë¥¼ ìž…ë ¥í•˜ì„¸ìš”")
        self.search_button = QPushButton("ì£¼ë³€ í´ë¦°í•˜ìš°ìŠ¤ ì°¾ê¸°")
        self.search_button.clicked.connect(self.search_nearby)
        self.result_list = QListWidget()
        self.map_view = QWebEngineView()
        self.map_view.setMinimumHeight(300)
        self.map_view.hide()
        self.layout.addWidget(QLabel("ðŸ  ì§‘ ì£¼ì†Œë¡œ ì£¼ë³€ í´ë¦°í•˜ìš°ìŠ¤ ì¶”ì²œ"))
        self.layout.addWidget(self.address_input)
        self.layout.addWidget(self.search_button)
        self.layout.addWidget(self.result_list)
        self.layout.addWidget(self.map_view)
        self.cleanhouse_df = load_cleanhouse_list("C:/ì½”ë”©/gonggongdeiteogwanri-keulrinhauseu-mogrog_202506111445.xlsx")
        self.result_list.itemClicked.connect(self.show_selected_map)
        self.nearest_df = None

    def search_nearby(self):
        try:
            address = self.address_input.text().strip()
            if not address:
                QMessageBox.warning(self, "ì˜¤ë¥˜", "ì£¼ì†Œë¥¼ ìž…ë ¥í•˜ì„¸ìš”.")
                return
            user_loc = geocode_address(address)
            if not user_loc:
                QMessageBox.warning(self, "ì˜¤ë¥˜", "ì£¼ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return
            lat, lng = user_loc
            nearest = find_nearest_cleanhouses(lat, lng, self.cleanhouse_df, top_n=5)
            self.result_list.clear()
            self.nearest_df = nearest
            for idx, row in nearest.iterrows():
                item_text = f"{row['ë„ë¡œëª…ì£¼ì†Œ']} ({row['ê±°ë¦¬']:.2f}km)"
                self.result_list.addItem(item_text)
            if not nearest.empty:
                self.show_map(nearest.iloc[0]['ìœ„ë„'], nearest.iloc[0]['ê²½ë„'], nearest.iloc[0]['ë„ë¡œëª…ì£¼ì†Œ'])
        except Exception as e:
            QMessageBox.critical(self, "ì˜¤ë¥˜", f"ê²€ìƒ‰ ì‹¤íŒ¨: {str(e)}")

    def show_selected_map(self, item):
        idx = self.result_list.currentRow()
        if self.nearest_df is not None and idx >= 0 and idx < len(self.nearest_df):
            row = self.nearest_df.iloc[idx]
            self.show_map(row['ìœ„ë„'], row['ê²½ë„'], row['ë„ë¡œëª…ì£¼ì†Œ'])

    def show_map(self, lat, lng, label):
        map_html = f"""
        <html>
        <body>
        <h4>{label}</h4>
        <iframe width="100%" height="300"
        src="https://maps.google.com/maps?q={lat},{lng}&z=16&output=embed"></iframe>
        </body>
        </html>
        """
        self.map_view.setHtml(map_html)
        self.map_view.show()

# ========== ê¸°ì¡´ FridgeAppì— íƒ­ ì¶”ê°€ ==========
class FridgeApp(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ëƒ‰ìž¥ê³  ìœ í†µê¸°í•œ ê´€ë¦¬ & í´ë¦°í•˜ìš°ìŠ¤ ì¶”ì²œ")
        self.food_list = []
        self.settings = {"night_notify": True, "notify_hours_before": 24}
        self.notified_items = set()
        self.init_ui()
        self.check_and_show_alerts()

    def init_ui(self):
        self.tabs = QTabWidget()
        # ìœ í†µê¸°í•œ ê´€ë¦¬ íƒ­
        self.fridge_tab = QWidget()
        self.fridge_layout = QVBoxLayout(self.fridge_tab)
        self.input_layout = QHBoxLayout()
        self.name_input = QLineEdit()
        self.name_input.setPlaceholderText("ì‹í’ˆ ì´ë¦„")
        self.date_input = QLineEdit()
        self.date_input.setPlaceholderText("ìœ í†µê¸°í•œ (YYYY-MM-DD)")
        self.add_button = QPushButton("ì¶”ê°€")
        self.add_button.clicked.connect(self.add_food)
        self.setting_button = QPushButton("âš™ï¸ ì„¤ì •")
        self.setting_button.clicked.connect(self.open_settings)
        self.input_layout.addWidget(self.name_input)
        self.input_layout.addWidget(self.date_input)
        self.input_layout.addWidget(self.add_button)
        self.input_layout.addWidget(self.setting_button)
        self.fridge_layout.addLayout(self.input_layout)
        self.time_label = QLabel()
        self.update_time_label()
        self.fridge_layout.addWidget(self.time_label)
        self.valid_list_widget = QListWidget()
        self.expired_list_widget = QListWidget()
        self.fridge_layout.addWidget(QLabel("âœ… ìœ íš¨í•œ ì‹í’ˆ ëª©ë¡"))
        self.fridge_layout.addWidget(self.valid_list_widget)
        self.fridge_layout.addWidget(QLabel("âš ï¸ ìœ í†µê¸°í•œ ì§€ë‚œ ì‹í’ˆ"))
        self.fridge_layout.addWidget(self.expired_list_widget)
        self.tabs.addTab(self.fridge_tab, "ìœ í†µê¸°í•œ ê´€ë¦¬")
        # í´ë¦°í•˜ìš°ìŠ¤ ì¶”ì²œ íƒ­
        self.cleanhouse_tab = CleanhouseFinder()
        self.tabs.addTab(self.cleanhouse_tab, "ì£¼ë³€ í´ë¦°í•˜ìš°ìŠ¤")
        main_layout = QVBoxLayout(self)
        main_layout.addWidget(self.tabs)
        self.setLayout(main_layout)
        # ìœ í†µê¸°í•œ ì¶”ì¶œ ë²„íŠ¼
        self.ocr_button = QPushButton("ðŸ“· ì´ë¯¸ì§€ë¡œ ë‚ ì§œ ì¸ì‹")
        self.ocr_button.clicked.connect(self.load_date_from_image)
        self.input_layout.addWidget(self.ocr_button)

    def update_time_label(self):
        self.time_label.setText(get_now().strftime("%Y-%m-%d %H:%M"))

    def add_food(self):
        name = self.name_input.text().strip()
        date_str = self.date_input.text().strip()
        if not name:
            QMessageBox.warning(self, "ì˜¤ë¥˜", "ì‹í’ˆ ì´ë¦„ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”.")
            return
        if any(item.name == name for item in self.food_list):
            QMessageBox.warning(self, "ì¤‘ë³µ í•­ëª©", f"'{name}'ì€(ëŠ”) ì´ë¯¸ ëª©ë¡ì— ìžˆìŠµë‹ˆë‹¤.")
            return
        try:
            item = FoodItem(name, date_str)
        except ValueError:
            QMessageBox.warning(self, "ì˜¤ë¥˜", "ë‚ ì§œ í˜•ì‹ì´ ìž˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤. YYYY-MM-DDë¡œ ìž…ë ¥í•´ì£¼ì„¸ìš”.")
            return
        self.food_list.append(item)
        self.update_lists()
        self.name_input.clear()
        self.date_input.clear()
        self.check_and_show_alerts(check_item=item)

    def update_lists(self):
        self.valid_list_widget.clear()
        self.expired_list_widget.clear()
        self.update_time_label()
        self.food_list.sort(key=lambda x: x.expiry_date)
        items_to_unnotify = set()
        for item_name in self.notified_items:
            found_item = next((item for item in self.food_list if item.name == item_name), None)
            if found_item and not found_item.is_expired() and found_item.time_left().total_seconds() / 3600 > self.settings["notify_hours_before"]:
                 items_to_unnotify.add(item_name)
        self.notified_items -= items_to_unnotify
        for item in self.food_list:
            if item.is_expired():
                self.expired_list_widget.addItem(str(item))
            else:
                self.valid_list_widget.addItem(str(item))

    def open_settings(self):
        dialog = SettingsDialog(self, current_settings=self.settings)
        if dialog.exec_():
            self.settings = dialog.get_settings()
            QMessageBox.information(self, "ì„¤ì • ì™„ë£Œ", "ì„¤ì •ì´ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            self.update_lists()
            self.check_and_show_alerts()

    def check_and_show_alerts(self, check_item=None):
        now = get_now()
        if not self.settings["night_notify"] and (now.hour >= 22 or now.hour < 8):
            return
        expired_alerts = []
        imminent_alerts = []
        items_to_check = [check_item] if check_item else self.food_list
        for item in items_to_check:
            if item.name in self.notified_items:
                continue
            hours_left = item.time_left().total_seconds() / 3600
            if item.is_expired():
                expired_alerts.append(item.name)
                self.notified_items.add(item.name)
            elif 0 <= hours_left <= self.settings["notify_hours_before"]:
                imminent_alerts.append(f"{item.name} ({int(hours_left)}ì‹œê°„ ë‚¨ìŒ)")
                self.notified_items.add(item.name)
        messages = []
        if expired_alerts:
            messages.append("--- ìœ í†µê¸°í•œ ë§Œë£Œ ---\n" + "\n".join(expired_alerts))
        if imminent_alerts:
            messages.append("--- ìœ í†µê¸°í•œ ìž„ë°• ---\n" + "\n".join(imminent_alerts))
        if messages:
            full_message = "\n\n".join(messages)
            QTimer.singleShot(0, lambda: QMessageBox.warning(self, "ì‹í’ˆ ì•Œë¦¼", full_message))

    # ìœ í†µê¸°í•œ ì¶”ì¶œ ë°ì´í„°ë¡œë“œ
    def load_date_from_image(self):
        fname, _ = QFileDialog.getOpenFileName(self, "ì´ë¯¸ì§€ ì„ íƒ", "", "Images (*.png *.jpg *.jpeg)")
        if fname:
            try:
                dates = use_by_date(fname)
                if not dates:
                    QMessageBox.information(self, "ì¸ì‹ ì‹¤íŒ¨", "ìœ í†µê¸°í•œ í˜•ì‹ì˜ ë‚ ì§œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                    return
                self.date_input.setText(dates[0])
                QMessageBox.information(self, "ë‚ ì§œ ì¸ì‹ ì„±ê³µ", f"ì¸ì‹ëœ ìœ í†µê¸°í•œ: {dates[0]}")
            except Exception as e:
                QMessageBox.critical(self, "ì˜¤ë¥˜", f"OCR ì‹¤íŒ¨: {str(e)}")

if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = FridgeApp()
    window.show()
    sys.exit(app.exec_())
